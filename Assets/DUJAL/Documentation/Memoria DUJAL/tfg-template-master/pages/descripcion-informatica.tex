\section{Requisitos}

En esta sección se abordarán los requisitos planteados en el paquete, tanto los iniciales como los que se han ido planteando a lo largo del desarrollo ya sean funcionales o no funcionales. 

\subsection{Requisitos Funcionales}
\begin{itemize}
    \item RF1. Como usuario puedo utilizar el editor de diálogos para crear cajas y conexiones que representen conversaciones.
    \item RF2. Como usuario puedo exportar los diálogos de forma que sean legibles por el código del juego.
    \item RF3. Como usuario puedo reproducir los diálogos en el juego.
    \item RF4. Como usuario puedo añadir etiquetas al texto para reproducir animaciones del texto.
    \item RF5. Como usuario puedo utilizar el sistema de guardado para que mi juego tenga datos persistentes.
    \item RF6. Como usuario puedo usar el sistema de carga para cargar y descargar recursos.
    \item RF7. Como usuario puedo manejar los sonidos que aparecen en mi juego a través del sistema de sonido.
    \item RF8. Como usuario puedo añadir un sistema de niveles a mi juego mediante el sistema de experiencia.
    \item RF9. Como usuario puedo insertar un personaje jugable con cámara en cualquier perspectiva.
    \item RF10. Como usuario puedo insertar un personaje jugable con movimiento basado en físicas o discreto.
    \item RF11. Como usuario puedo insertar un personaje jugable ya sea en 2D o 3D.
    \item RF12. Como usuario puedo depurar las herramientas del paquete.
    \item RF13. Como usuario puedo generar una mazmorra o un laberinto usando el generador de mazmorras.
    \item RF14. Como usuario puedo utilizar algoritmos para encontrar el camino mínimo para salir de un laberinto o llegar a la hora de una mazmorra.
    \item RF15. Como usuario puedo modificar el tamaño y posición de una mazmorra.
    \item RF16. Como usuario puedo hacer que un objeto flote y rote.
    \item RF17. Como usuario puedo añadir interacciones a mi juego.
    \item RF18. Como usuario puedo añadir vida, daño y muerte a mi juego.
    \item RF19. Como usuario puedo añadir lanzar un objeto que utilice físicas en cualquier dirección.
    \item RF20. Como usuario puedo hacer que un objeto siempre mire a cámara.
    \item RF21. Como usuario puedo utilizar curvas de animación para sacudir la cámara en 2D y 3D, para cámaras de Unity y Cinemachine.
\end{itemize}

\subsection{Requisitos No Funcionales}

\begin{itemize}
    \item RNF1. Los módulos del paquete deben ser escalables.
    \item RNF2. Los módulos del paquete deben estar documentados.
    \item RNF3. El código del paquete debe ser legible y estar bien estructurado.
    \item RNF4. El paquete debe ser usable y recibir buenos resultados en las encestas de satisfacción.
\end{itemize}

\section{Herramientas y Tecnologías}

\subsection{C\# \& Unity}

Se ha utilizado Unity\cite{unity} como motor para el que está diseñado el paquete y C\#\cite{csharp} como lenguaje de programación, se ha elegido este motor dado que era el motor público más utilizado por estudiantes y equipos pequeños y medianos.

\subsection{Visual Studio}

Visual Studio\cite{visualstudio} es un IDE y editor de código para C++ y .Net y C\#, es el editor de código por defecto de Unity y el que se ha utilizado por defecto para el desarrollo del proyecto. 

\subsection{Git \& Github}

Github\cite{github} es un entorno de desarrollo colaborativo y control de versiones web basado en la tecnología Git. Para mantener el proyecto y poder trabajar en el desde distintos equipos, se ha alojado el proyecto de del paquete\cite{Repo} en él.

\subsection{UniTask}

UniTask\cite{UniTask} es una librería que ofrece una implementación de async/await sin necesidad de alocataciones de memoria basada en estructuras. Se ha aprovechado esta librería para la implementación del sistema de carga de escenas, ya que permite un funcionamiento asíncrono.

\section{Arquitectura y Análisis}
aaaa
\subsection{Clases pues las que toquen aqui}
aaa

\begin{mypython}[caption={Ejemplo de código utilizado para definir la animación de "Wobble" en el texto.},label={alg:wobbleAnimation}]
    foreach (EffectInstance effect in effects) 
    {
        for (int i = effect.TextStartIdx; i < effect.GetTextEndIndex(); ++i)
        {
            var charInfo = animationHandler.TextInfo.characterInfo[i];
            if (!charInfo.isVisible)
            {
                continue;
            }
            
            var meshInfo = animationHandler.TextInfo.meshInfo[charInfo.materialReferenceIndex];
            var verts = meshInfo.vertices;
            for (int j = 0; j < 4; ++j)
            {
                int vertexIdx = charInfo.vertexIndex + j;
                float newOrigY = Mathf.Sin(Time.time * _speed[effectIdx] + verts[vertexIdx].x * 0.01f) * _amplitude[effectIdx];
                verts[vertexIdx] = verts[vertexIdx] + new Vector3(0f, newOrigY, 0f);
            }
        }
        effectIdx++;
    }
\end{mypython}